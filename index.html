<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Weather RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #2c2c2c;
            color: #e0e0e0;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            cursor: crosshair;
            border-radius: 0.5rem;
            border: 4px solid #5a5a5a;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
        }
        .ui-panel {
            background-color: #3e3e3e;
            border: 4px solid #5a5a5a;
            padding: 1rem;
            border-radius: 0.5rem;
        }
        .weapon-btn {
            transition: all 0.2s ease;
        }
        .weapon-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 15px #fef08a; /* yellow-200 */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            border: 4px solid #fef08a;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 100;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center h-screen">

    <div id="game-container" class="game-container">
        <h1 class="text-3xl mb-4 text-yellow-300">Duck Weather RPG</h1>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="ui-panel mt-4 w-full max-w-4xl flex justify-between items-center">
            <!-- Player Stats -->
            <div>
                <h2 class="text-lg">STATS</h2>
                <div id="health-bar-container" class="w-48 bg-gray-700 rounded h-6 mt-1 border-2 border-gray-500">
                    <div id="health-bar" class="bg-red-500 h-full rounded-sm" style="width: 100%;"></div>
                </div>
                <p class="text-sm mt-1">Health: <span id="health-value">100</span>/100</p>
            </div>

            <!-- Weather Info -->
            <div class="text-center">
                 <h2 class="text-lg">WEATHER</h2>
                 <p id="weather-status" class="text-2xl font-bold text-cyan-300">Sunny</p>
                 <p id="weather-effect" class="text-xs text-yellow-300"></p>
            </div>
            
            <!-- Weapon Selection -->
            <div>
                <h2 class="text-lg">WEAPONS</h2>
                <div class="flex space-x-2 mt-1">
                    <button id="weapon-0" class="weapon-btn p-2 bg-gray-600 rounded border-2 border-gray-500 hover:bg-gray-500 active">
                        <span class="text-xl">üó°Ô∏è</span>
                        <p class="text-xs">Iron Sword</p>
                    </button>
                    <button id="weapon-1" class="weapon-btn p-2 bg-gray-600 rounded border-2 border-gray-500 hover:bg-gray-500">
                         <span class="text-xl">‚öîÔ∏è</span>
                         <p class="text-xs">Steel Greatsword</p>
                    </button>
                    <button id="weapon-2" class="weapon-btn p-2 bg-gray-600 rounded border-2 border-gray-500 hover:bg-gray-500">
                         <span class="text-xl">‚ú®</span>
                         <p class="text-xs">Sun Blade</p>
                    </button>
                </div>
            </div>
        </div>
        <p class="mt-2 text-xs text-gray-400">Use WASD or Arrow Keys to move. Click to attack in a direction.</p>
    </div>

    <div id="message-box" class="message-box hidden">
        <h2 id="message-title" class="text-2xl mb-4">Game Over</h2>
        <p id="message-text" class="mb-6">The IMT Lazarus forces were too strong!</p>
        <button id="restart-button" class="px-4 py-2 bg-yellow-400 text-gray-900 rounded hover:bg-yellow-300">Restart Game</button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- UI Elements ---
        const healthBar = document.getElementById('health-bar');
        const healthValue = document.getElementById('health-value');
        const weatherStatus = document.getElementById('weather-status');
        const weatherEffect = document.getElementById('weather-effect');
        const weaponButtons = [
            document.getElementById('weapon-0'),
            document.getElementById('weapon-1'),
            document.getElementById('weapon-2'),
        ];
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');

        // --- Game Constants ---
        const TILE_SIZE = 40;
        const MAP_WIDTH = canvas.width / TILE_SIZE;
        const MAP_HEIGHT = canvas.height / TILE_SIZE;
        const PLAYER_SPEED = 3;

        // --- Game State ---
        let player, enemies, map, weather, weapons;
        let keys = {};
        let gameOver = false;
        let gameWon = false;

        // --- Game Assets and Config ---
        const colors = {
            plains: { grass: '#6a994e', path: '#bc6c25', rock: '#6c757d' },
            cave: { floor: '#4a4e69', wall: '#22223b', water: '#0077b6' },
            player: '#ffc300',
            enemy: '#d00000',
            attack: '#ffffff'
        };

        const weaponsConfig = [
            { name: "Iron Sword", damage: 10, range: 50, cooldown: 400, emoji: 'üó°Ô∏è' },
            { name: "Steel Greatsword", damage: 15, range: 65, cooldown: 600, emoji: '‚öîÔ∏è' },
            { name: "Sun Blade", damage: 20, range: 80, cooldown: 500, emoji: '‚ú®' }
        ];

        const weatherTypes = [
            { name: 'Sunny', effect: 'None', color: 'rgba(255, 240, 150, 0.1)', buff: { damage: 0, speed: 0 } },
            { name: 'Rainy', effect: '+2 Speed', color: 'rgba(100, 150, 255, 0.2)', buff: { damage: 0, speed: 2 } },
            { name: 'Windy', effect: '+2 Damage', color: 'rgba(200, 200, 200, 0.15)', buff: { damage: 2, speed: 0 } },
            { name: 'Stormy', effect: '+3 Dmg, +1 Speed', color: 'rgba(50, 50, 100, 0.3)', buff: { damage: 3, speed: 1 } },
        ];
        
        // Map Layout (0: grass/floor, 1: rock/wall, 2: path)
        const mapLayout = [
            // Plains Area
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,0,0,2,2,2,2,2,2,2,2,0,0,1,0,0,1],
            [1,0,1,1,0,0,2,0,0,1,1,0,0,2,0,0,1,1,0,1],
            [1,0,0,0,0,0,2,0,0,1,1,0,0,2,0,0,0,0,0,1],
            [1,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0], // Transition row
            [1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1],
            // Cave Area
            [1,3,3,3,3,3,2,3,3,3,3,3,3,2,3,3,3,3,3,1],
            [1,3,4,4,4,3,2,3,4,4,4,4,3,2,3,4,4,4,3,1],
            [1,3,4,3,4,3,2,3,4,3,4,3,4,2,3,4,3,4,3,1],
            [1,3,4,4,4,3,2,3,4,4,4,4,3,2,3,4,4,4,3,1],
            [1,3,3,3,3,3,2,3,3,3,3,3,3,2,3,3,3,3,3,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];


        // --- Utility Functions ---
        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function showMessage(title, text) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
        }

        function findValidSpawnPoint(zone) {
            let x, y, tileX, tileY, tileType;
            const padding = TILE_SIZE; 

            // Define Y boundaries for spawning based on the zone
            const yMin = zone === 'plains' ? padding : (canvas.height / 2);
            const yMax = zone === 'plains' ? (canvas.height / 2) : (canvas.height - padding);

            do {
                x = Math.random() * (canvas.width - padding * 2) + padding;
                y = Math.random() * (yMax - yMin) + yMin;
                tileX = Math.floor(x / TILE_SIZE);
                tileY = Math.floor(y / TILE_SIZE);
                // Ensure tile coordinates are within the map bounds before checking
                tileType = (mapLayout[tileY] && mapLayout[tileY][tileX] !== undefined) ? mapLayout[tileY][tileX] : 1;
            } while (tileType === 1 || tileType === 4); // Keep trying if it's a wall or water

            return { x, y };
        }

        // --- Game Object Classes ---
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TILE_SIZE * 0.7;
                this.health = 100;
                this.maxHealth = 100;
                this.currentWeapon = 0;
                this.lastAttackTime = 0;
                this.attackAngle = 0;
                this.isAttacking = false;
                this.attackDuration = 150; // ms
                this.attackStartTime = 0;
            }

            draw() {
                // Draw attack animation
                if (this.isAttacking) {
                    const weapon = weapons[this.currentWeapon];
                    ctx.save();
                    ctx.beginPath();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.attackAngle);
                    ctx.fillStyle = colors.attack;
                    ctx.globalAlpha = 0.6;
                    ctx.arc(weapon.range / 2, 0, weapon.range / 2, -Math.PI/2.5, Math.PI/2.5);
                    ctx.lineTo(0, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                // Draw health bar over player
                if (this.health < this.maxHealth) {
                    const barWidth = this.size;
                    const barHeight = 6;
                    const yOffset = this.size / 2 + 8;
                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    // Health
                    ctx.fillStyle = '#22c55e'; // A nice green for the player
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                     // Border
                    ctx.strokeStyle = '#111';
                    ctx.strokeRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                }

                // Draw player
                ctx.fillStyle = colors.player;
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ü¶Ü', this.x, this.y);
            }

            update() {
                const speed = PLAYER_SPEED + weather.buff.speed;
                let newX = this.x;
                let newY = this.y;

                if (keys['w'] || keys['ArrowUp']) newY -= speed;
                if (keys['s'] || keys['ArrowDown']) newY += speed;
                if (keys['a'] || keys['ArrowLeft']) newX -= speed;
                if (keys['d'] || keys['ArrowRight']) newX += speed;

                if (!this.isColliding(newX, this.y)) this.x = newX;
                if (!this.isColliding(this.x, newY)) this.y = newY;
                
                // Keep player within canvas bounds
                this.x = Math.max(this.size / 2, Math.min(canvas.width - this.size / 2, this.x));
                this.y = Math.max(this.size / 2, Math.min(canvas.height - this.size / 2, this.y));

                // Handle attack animation timeout
                if (this.isAttacking && Date.now() - this.attackStartTime > this.attackDuration) {
                    this.isAttacking = false;
                }
            }

            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4; // 1: rock/wall, 4: water
            }

            attack(targetX, targetY) {
                const now = Date.now();
                const weapon = weapons[this.currentWeapon];
                if (now - this.lastAttackTime < weapon.cooldown) return;

                this.lastAttackTime = now;
                this.attackStartTime = now;
                this.isAttacking = true;
                this.attackAngle = Math.atan2(targetY - this.y, targetX - this.x);

                const totalDamage = weapon.damage + weather.buff.damage;

                enemies.forEach(enemy => {
                    const dist = getDistance(this, enemy);
                    if (dist < weapon.range + enemy.size / 2) {
                        const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                        let angleDiff = Math.abs(this.attackAngle - angleToEnemy);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

                        if (angleDiff < Math.PI / 2.5) { // Attack arc
                            enemy.takeDamage(totalDamage);
                        }
                    }
                });
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if(this.health <= 0) {
                    this.health = 0;
                    gameOver = true;
                    showMessage("Game Over", "The IMT Lazarus forces were too strong!");
                }
                updateUI();
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TILE_SIZE * 0.8;
                this.health = 30;
                this.maxHealth = 30;
                this.speed = 1.5;
                this.damage = 5;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.aggroRange = TILE_SIZE * 6;
            }

            draw() {
                // Draw enemy
                ctx.fillStyle = colors.enemy;
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('L', this.x, this.y);

                // Draw health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.size;
                    const barHeight = 5;
                    const yOffset = this.size / 2 + 5;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }

            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4; // 1: rock/wall, 4: water
            }

            update() {
                const dist = getDistance(this, player);

                if (dist < this.aggroRange && dist > player.size / 2) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const newX = this.x + Math.cos(angle) * this.speed;
                    const newY = this.y + Math.sin(angle) * this.speed;

                    if (!this.isColliding(newX, this.y)) this.x = newX;
                    if (!this.isColliding(this.x, newY)) this.y = newY;
                }

                if (dist < player.size / 2 + 5) {
                     const now = Date.now();
                     if (now - this.lastAttackTime > this.attackCooldown) {
                         player.takeDamage(this.damage);
                         this.lastAttackTime = now;
                     }
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
            }
        }

        // --- Game Setup and Loop ---
        function init() {
            gameOver = false;
            gameWon = false;
            messageBox.classList.add('hidden');

            player = new Player(TILE_SIZE * 2, TILE_SIZE * 2);
            
            enemies = [];
            // Spawn 5 enemies in the plains area
            for (let i = 0; i < 5; i++) {
                const spawnPoint = findValidSpawnPoint('plains');
                enemies.push(new Enemy(spawnPoint.x, spawnPoint.y));
            }
             // Spawn 7 enemies in the cave area
             for (let i = 0; i < 7; i++) {
                const spawnPoint = findValidSpawnPoint('cave');
                enemies.push(new Enemy(spawnPoint.x, spawnPoint.y));
            }

            map = mapLayout;
            weapons = weaponsConfig;
            weather = weatherTypes[0];
            
            player.currentWeapon = 0;
            updateWeaponUI();
            updateUI();
            
            // Set up weather changes
            setInterval(changeWeather, 20000); // Change weather every 20 seconds
        }

        function changeWeather() {
            const randomIndex = Math.floor(Math.random() * weatherTypes.length);
            weather = weatherTypes[randomIndex];
            updateUI();
        }

        function drawMap() {
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    let tileType = map[y][x];
                    let color;
                    // Plains
                    if (y < 8) { 
                        if (tileType === 0) color = colors.plains.grass;
                        else if (tileType === 1) color = colors.plains.rock;
                        else if (tileType === 2) color = colors.plains.path;
                    // Cave
                    } else {
                        if (tileType === 0 || tileType === 3) color = colors.cave.floor;
                        else if (tileType === 1) color = colors.cave.wall;
                        else if (tileType === 2) color = colors.plains.path; // path continues
                        else if (tileType === 4) color = colors.cave.water;
                    }
                     if (y === 7 || y === 8) color = '#454545'; // Transition tunnel

                    ctx.fillStyle = color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        function updateUI() {
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            healthValue.textContent = `${player.health}/${player.maxHealth}`;
            weatherStatus.textContent = weather.name;
            weatherEffect.textContent = weather.effect;
        }
        
        function updateWeaponUI() {
            weaponButtons.forEach((btn, index) => {
                if (index === player.currentWeapon) {
                    btn.classList.add('active', 'border-yellow-300');
                } else {
                    btn.classList.remove('active', 'border-yellow-300');
                }
            });
        }


        function gameLoop() {
            if (gameOver || gameWon) {
                return;
            }
            
            // 1. Update game objects
            player.update();
            enemies.forEach(enemy => enemy.update());
            
            // Remove dead enemies
            enemies = enemies.filter(enemy => enemy.health > 0);

            if (enemies.length === 0 && !gameWon) {
                gameWon = true;
                showMessage("Victory!", "You have defeated all IMT Lazarus minions!");
            }

            // 2. Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 3. Draw game objects
            drawMap();
            enemies.forEach(enemy => enemy.draw());
            player.draw();

            // Draw weather overlay
            ctx.fillStyle = weather.color;
            ctx.fillRect(0,0, canvas.width, canvas.height);

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            player.attack(mouseX, mouseY);
        });

        weaponButtons.forEach((btn, index) => {
            btn.addEventListener('click', () => {
                player.currentWeapon = index;
                updateWeaponUI();
            });
        });

        restartButton.addEventListener('click', () => {
            init();
            gameLoop();
        });

        // --- Start Game ---
        init();
        gameLoop();

    </script>
</body>
</html>



