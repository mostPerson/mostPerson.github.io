<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Weather RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden;
        }
        canvas {
            background-color: #162447;
            cursor: crosshair;
            border-radius: 0.5rem;
            border: 4px solid #1f4068;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
        }
        .ui-panel {
            background-color: rgba(0,0,0,0.5);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
        }
        .weapon-btn {
            background-color: #4a5568;
            border: 2px solid #2d3748;
            transition: all 0.2s;
            font-size: 0.7rem; /* Smaller font for more weapons */
        }
        .weapon-btn.active {
            background-color: #a0aec0;
            border-color: #718096;
            transform: scale(1.1);
        }
        /* New class for settings buttons */
        .setting-btn {
            background-color: #4a5568;
            border: 2px solid #2d3748;
            transition: all 0.2s;
            width: 300px;
        }
        .setting-btn.active {
            background-color: #6ee7b7;
            border-color: #86efac;
            color: #1a1a2e;
        }
        .hidden {
            display: none;
        }
        .gui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        .gui-button {
            padding: 0.75rem 2rem;
            font-size: 1.25rem;
            color: #1a1a2e;
            background-color: #6ee7b7;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        .gui-button:hover {
            transform: scale(1.05);
            background-color: #86efac;
        }
        #gui-editor {
            background-color: rgba(10, 10, 20, 0.95);
            z-index: 20; /* Above other overlays */
        }
        .tile-palette-item {
            width: 40px;
            height: 40px;
            border: 2px solid #4a5568;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tile-palette-item.selected {
            border-color: #fcd34d;
            transform: scale(1.15);
        }
        #level-data-textarea {
            background-color: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            resize: none;
        }
    </style>
</head>
<body>
    <div id="game-container" class="game-container relative">
        <canvas id="gameCanvas" width="960" height="540"></canvas>
        
        <div id="ui-panel" class="ui-panel mt-4 w-full max-w-4xl text-sm hidden">
            <div class="flex justify-between items-center">
                <div>
                    Health: <span id="health" class="text-green-400">100</span> | 
                    Level: <span id="level" class="text-yellow-300">1</span> |
                    <span id="enemies-label">Enemies:</span> <span id="enemies-left" class="text-red-400">0</span>
                </div>
                 <div>Timer: <span id="timer" class="text-white">00:00:000</span></div>
                <div>Weather: <span id="weather" class="text-cyan-300">Clear</span> (<span id="weather-timer" class="text-cyan-300">20</span>s)</div>
            </div>
            <div id="weapon-select" class="flex justify-center gap-4 mt-2">
                <!-- Weapon buttons will be generated here -->
            </div>
        </div>

        <!-- GUI Overlays -->
        <!-- Chapter 1 Main Menu -->
        <div id="gui-menu-ch1" class="gui-overlay">
            <h1 class="text-5xl text-yellow-300 mb-4">Duck Weather RPG</h1>
            <p class="text-lg text-gray-300 mb-2 max-w-md">Chapter 1: The Lazarus Threat</p>
            <div class="flex flex-col gap-4">
                <button id="start-button-ch1" class="gui-button">Start Adventure</button>
                <button id="editor-button-ch1" class="gui-button bg-blue-400 hover:bg-blue-300">Level Editor (Ch 1)</button>
                <button id="settings-button-ch1" class="gui-button bg-gray-500 hover:bg-gray-400">Settings</button>
                <button id="goto-ch2-button" class="gui-button bg-purple-500 hover:bg-purple-400">Go to Chapter 2</button>
            </div>
        </div>
        
        <!-- Chapter 2 Main Menu -->
        <div id="gui-menu-ch2" class="gui-overlay hidden">
            <h1 class="text-5xl text-blue-300 mb-4">Duck Weather RPG</h1>
            <p class="text-lg text-gray-300 mb-2 max-w-md">Chapter 2: The EUROPE Conspiracy</p>
            <div class="flex flex-col gap-4">
                <button id="start-button-ch2" class="gui-button">Start Adventure</button>
                <button id="editor-button-ch2" class="gui-button bg-blue-400 hover:bg-blue-300">Level Editor (Ch 2)</button>
                <button id="settings-button-ch2" class="gui-button bg-gray-500 hover:bg-gray-400">Settings</button>
                <button id="goto-ch1-button" class="gui-button bg-purple-500 hover:bg-purple-400">Back to Chapter 1</button>
            </div>
        </div>

        <div id="gui-message" class="gui-overlay hidden">
            <h2 id="message-title" class="text-4xl mb-4"></h2>
            <p id="message-text" class="text-lg mb-8"></p>
            <button id="message-button" class="gui-button"></button>
        </div>

        <div id="gui-pause" class="gui-overlay hidden">
            <h2 class="text-4xl text-yellow-300 mb-8">Paused</h2>
            <div class="flex flex-col gap-4">
                <button id="resume-button" class="gui-button">Resume</button>
                <button id="main-menu-button" class="gui-button bg-red-500 hover:bg-red-400">Main Menu</button>
            </div>
        </div>

        <!-- Settings Menu -->
        <div id="gui-settings" class="gui-overlay hidden">
            <h2 class="text-3xl text-yellow-300 mb-6">Settings</h2>
            <div class="flex flex-col gap-4">
                <h3 class="text-xl">Attack Controls</h3>
                <div class="flex flex-col gap-3">
                    <button id="setting-attack-mouse" class="gui-button setting-btn active">Mouse</button>
                    <button id="setting-attack-arrows" class="gui-button setting-btn">Arrow Keys</button>
                    <button id="setting-attack-wasd" class="gui-button setting-btn">WASD</button>
                </div>

                <h3 class="text-xl mt-4">Movement Controls</h3>
                <div class="flex flex-col gap-3">
                    <button id="setting-move-arrows" class="gui-button setting-btn active">Arrow Keys</button>
                    <button id="setting-move-wasd" class="gui-button setting-btn">WASD</button>
                </div>
            </div>
             <button id="settings-back-button" class="gui-button mt-8 bg-gray-500 hover:bg-gray-400">Back</button>
        </div>

        <div id="gui-editor" class="gui-overlay hidden">
             <h2 class="text-3xl text-yellow-300 mb-4">Level Editor</h2>
             <div class="flex gap-4 items-start">
                <div class="flex flex-col gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
                    <h3 class="text-sm border-b border-gray-600 pb-1">Tiles</h3>
                    <div id="tile-palette" class="grid grid-cols-3 gap-2">
                        <!-- Tiles will be generated here -->
                    </div>
                </div>
                <div class="flex flex-col gap-3">
                     <textarea id="level-data-textarea" class="w-96 h-24 p-2 rounded text-xs" placeholder="Paste level data here..."></textarea>
                     <div class="grid grid-cols-2 gap-2">
                         <button id="copy-level-btn" class="gui-button text-sm p-2 bg-purple-500 hover:bg-purple-400">Copy Layout</button>
                         <button id="paste-level-btn" class="gui-button text-sm p-2 bg-purple-500 hover:bg-purple-400">Paste Layout</button>
                         <button id="test-level-btn" class="gui-button text-sm p-2 col-span-2 bg-green-500 hover:bg-green-400">Test Level</button>
                     </div>
                </div>
             </div>
             <button id="exit-editor-btn" class="gui-button mt-4 bg-red-500 hover:bg-red-400">Exit Editor</button>
        </div>
    </div>

    <script>
        // --- Canvas and UI Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        const healthUI = document.getElementById('health');
        const levelUI = document.getElementById('level');
        const enemiesLabelUI = document.getElementById('enemies-label');
        const enemiesLeftUI = document.getElementById('enemies-left');
        const weatherUI = document.getElementById('weather');
        const weatherTimerUI = document.getElementById('weather-timer');
        const weaponSelectUI = document.getElementById('weapon-select');
        const timerUI = document.getElementById('timer');
        
        // Menus
        const guiMenuCh1 = document.getElementById('gui-menu-ch1');
        const guiMenuCh2 = document.getElementById('gui-menu-ch2');
        const startButtonCh1 = document.getElementById('start-button-ch1');
        const editorButtonCh1 = document.getElementById('editor-button-ch1');
        const settingsButtonCh1 = document.getElementById('settings-button-ch1');
        const gotoCh2Button = document.getElementById('goto-ch2-button');
        const startButtonCh2 = document.getElementById('start-button-ch2');
        const editorButtonCh2 = document.getElementById('editor-button-ch2');
        const settingsButtonCh2 = document.getElementById('settings-button-ch2');
        const gotoCh1Button = document.getElementById('goto-ch1-button');

        const guiMessage = document.getElementById('gui-message');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');
        const guiPause = document.getElementById('gui-pause');
        const resumeButton = document.getElementById('resume-button');
        const mainMenuButton = document.getElementById('main-menu-button');

        // Settings UI
        const guiSettings = document.getElementById('gui-settings');
        const settingAttackMouse = document.getElementById('setting-attack-mouse');
        const settingAttackArrows = document.getElementById('setting-attack-arrows');
        const settingAttackWasd = document.getElementById('setting-attack-wasd');
        const settingsBackButton = document.getElementById('settings-back-button');
        const attackSettingButtons = [settingAttackMouse, settingAttackArrows, settingAttackWasd];

        // New Move Settings UI
        const settingMoveArrows = document.getElementById('setting-move-arrows');
        const settingMoveWasd = document.getElementById('setting-move-wasd');
        const moveSettingButtons = [settingMoveArrows, settingMoveWasd];

        // Editor UI
        const guiEditor = document.getElementById('gui-editor');
        const tilePalette = document.getElementById('tile-palette');
        const exitEditorBtn = document.getElementById('exit-editor-btn');
        const copyLevelBtn = document.getElementById('copy-level-btn');
        const pasteLevelBtn = document.getElementById('paste-level-btn');
        const testLevelBtn = document.getElementById('test-level-btn');
        const levelDataTextarea = document.getElementById('level-data-textarea');


        // --- Game Constants ---
        const TILE_SIZE = 40;
        const PLAYER_SPEED = 3.5;
        const colors = {
            player: 'yellow',
            enemy: '#f87171', // red-400
            enemyEurope: '#60a5fa', // blue-400
            boss: '#e11d48', // rose-600
            bossEurope: '#f59e0b', // amber-500
            projectile: '#f43f5e', // rose-500
            projectileEurope: '#fbbf24', // amber-400
            attack: 'rgba(255, 255, 255, 0.3)',
            tiles: {
                0: '#4ade80', // green-400 (grass)
                1: '#78716c', // stone-500 (rock/wall)
                2: '#a16207', // yellow-700 (path)
                3: '#4338ca', // indigo-700 (cave floor)
                4: '#2563eb', // blue-600 (water)
                5: '#a3a3a3', // neutral-400 (castle floor)
                6: '#dc2626', // red-600 (boss floor)
                7: '#9ca3af', // gray-400 (cobblestone)
                8: '#b91c1c', // red-700 (red carpet)
                9: '#22c55e', // green-500 (park grass)
            }
        };

        // --- Game State ---
        let player, enemies = [], projectiles = [], bosses = [], map, weapons, weather, weatherInterval, gameLoopId;
        let keys = {};
        let currentChapter = 1;
        let currentLevel = 0;
        let gameState = 'menu-ch1'; // 'menu-ch1', 'menu-ch2', 'playing', 'paused', 'levelup', 'gameover', 'editor'
        let lastMenuState = 'menu-ch1';
        let mouse = { x: 0, y: 0, down: false };
        let startTime = 0;
        let finalTime = "00:00:000";
        let isTestingLevel = false;
        let editorBrush = 1;
        let settings = {
            attack: 'mouse', // 'mouse', 'arrowkeys', 'wasd'
            move: 'arrowkeys' // 'arrowkeys', 'wasd'
        };

        // --- Game Data ---
        const weaponsConfig = {
            broadsword: { name: "Broadsword", damage: 12, range: TILE_SIZE * 1.5, cooldown: 500 },
            dagger: { name: "Dagger", damage: 8, range: TILE_SIZE * 0.9, cooldown: 250 },
            greatsword: { name: "Greatsword", damage: 20, range: TILE_SIZE * 2.2, cooldown: 900 },
            katana: { name: "Katana", damage: 10, range: TILE_SIZE * 2.5, cooldown: 450 } // Nerfed: Cooldown increased from 450
        };

        // Moved weatherTypes to global scope
        const weatherTypes = [
            { name: "Sunny", effect: "speed", value: 1.2, color: "#fcd34d" },
            { name: "Rainy", effect: "defense", value: 0.75, color: "#60a5fa" },
            { name: "Windy", effect: "attackSpeed", value: 0.8, color: "#9ca3af" },
            { name: "Stormy", effect: "damage", value: 1.5, color: "#a78bfa" },
        ];

        const chapterData = {
            1: {
                name: "Chapter 1: The Lazarus Threat",
                enemyClass: "Lazarus",
                bossClass: "Lazarus",
                weapons: [weaponsConfig.broadsword, weaponsConfig.dagger, weaponsConfig.greatsword],
                levels: [
                    { name: "The Sunny Plains", enemyCount: 5, map: ["111111111111111111111111","100022200000004444000001","100220020000044444400001","102200002220004440000001","100000000022000000002201","100000000002222222222001","111111111111111111111111"] },
                    { name: "The Dank Cave", enemyCount: 8, map: ["111111111111111111111111","133313333333333331333331","134431333111331113334431","13443133333133133334431","133331113331331333333331","133333333333333333333331","111111111111111111111111"] },
                    { name: "Lazarus's Keep", enemyCount: 10, map: ["111111111111111111111111","155555555555555555555551","151115511155111551115511","155555555555555555555551","115511155111551115511155","155555555555555555555551","111111111111111111111111"] },
                    { name: "Throne of Lazarus", enemyCount: 1, boss: "Lazarus", map: ["111111111111111111111111","166666666666666666666661","166661111111111111166661","166661666666666666166661","166661111111111111166661","166666666666666666666661","111111111111111111111111"] },
                    { name: "Custom Level (Ch 1)", enemyCount: 5, map: ["111111111111111111111111","100000000000000000000001","100000000000000000000001","100000000000000000000001","100000000000000000000001","100000000000000000000001","111111111111111111111111"] }
                ]
            },
            2: {
                name: "Chapter 2: The EUROPE Conspiracy",
                enemyClass: "Europe",
                bossClass: "Europe",
                weapons: [weaponsConfig.broadsword, weaponsConfig.dagger, weaponsConfig.greatsword, weaponsConfig.katana],
                levels: [
                    { name: "London Streets", enemyCount: 10, map: ["111111111111111111111111","177777777777777777777771","174447774447744477444771","174447774447744477444771","177777777777777777777771","177777777777777777777771","111111111111111111111111"] },
                    { name: "Parisian Park", enemyCount: 8, map: ["111111111111111111111111","199999999999999999999991","19222994444444499222991","192229944444CSSS44499222991","19999994444444499999991","199999999999999999999991","111111111111111111111111"] },
                    { name: "The Big Ben", enemyCount: 1, boss: "BigBen", map: ["111111111111111111111111","177777777777777777777771","177777777778877777777771","17777778888887777777771","177777777778877777777771","177777777777777777777771","111111111111111111111111"] },
                    { name: "Berlin Underground", enemyCount: 10, map: ["111111111111111111111111","133311333333331133333331","133311333111113331133331","133333333111113333333331","133311133333333111333331","133311133333333111333331","111111111111111111111111"] },
                    { name: "Roman Ruins", enemyCount: 12, map: ["111111111111111111111111","122122122122122122122122","122122122122122122122122","122122122122122122122122","122122122122122122122122","122222222222222222222221","111111111111111111111111"] },
                    { name: "The Eiffel Tower", enemyCount: 1, boss: "EiffelTower", map: ["111111111111111111111111","199999999999999999999991","19999999998899999999991","19999999888889999999991","19999999998899999999991","199999999999999999999991","111111111111111111111111"] },
                    { name: "Custom Level (Ch 2)", enemyCount: 5, map: ["111111111111111111111111","170000000000000000000071","100000000000000000000001","100000000000000000000001","100000000000000000000001","170000000000000000000071","111111111111111111111111"] }
                ]
            }
        };
        
        let mapLayout = []; // Will be populated by loadLevel
        
        // --- Utility Functions ---
        function getDistance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function findValidSpawnPoint() {
            let x, y, tileX, tileY, tileType;
            const padding = TILE_SIZE; 
            let attempts = 0;
            do {
                x = Math.random() * (canvas.width - padding * 2) + padding;
                y = Math.random() * (canvas.height - padding * 2) + padding;
                tileX = Math.floor(x / TILE_SIZE);
                tileY = Math.floor(y / TILE_SIZE);
                tileType = (map[tileY] && map[tileY][tileX] !== undefined) ? map[tileY][tileX] : 1;
                attempts++;
                if (attempts > 100) return { x: TILE_SIZE * 2, y: TILE_SIZE * 2 }; // Failsafe
            } while (tileType === 1 || tileType === 4); 
            return { x, y };
        }
        
        function showGUI(title, text, buttonText, callback) {
            gameState = 'paused';
            messageTitle.textContent = title;
            if ((title === "You Win!" || title === "Game Over") && !isTestingLevel) {
                 messageText.textContent = `${text} Your time: ${finalTime}`;
            } else {
                messageText.textContent = text;
            }
            messageButton.textContent = buttonText;
            messageButton.onclick = callback;
            guiMessage.classList.remove('hidden');
        }
        
        function updateTimer() {
            if (gameState !== 'playing') return;
            const elapsed = Date.now() - startTime;
            const minutes = String(Math.floor(elapsed / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsed % 60000) / 1000)).padStart(2, '0');
            const milliseconds = String(elapsed % 1000).padStart(3, '0');
            finalTime = `${minutes}:${seconds}:${milliseconds}`;
            timerUI.textContent = finalTime;
        }

        // --- Game Object Classes ---
        class Player {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = TILE_SIZE;
                this.maxHealth = 100;
                this.health = 100;
                this.baseSpeed = PLAYER_SPEED;
                this.currentWeapon = 0;
                this.lastAttackTime = 0;
                this.isAttacking = false;
                this.attackAnimTimeout = null;
                this.attackAngle = 0; 
            }
            draw() {
                if (this.isAttacking) {
                    const weapon = weapons[this.currentWeapon];
                    ctx.save(); ctx.beginPath(); ctx.translate(this.x, this.y);
                    ctx.rotate(this.attackAngle); 
                    ctx.fillStyle = colors.attack; ctx.globalAlpha = 0.6;
                    ctx.arc(weapon.range / 2, 0, weapon.range / 2, -Math.PI/2.5, Math.PI/2.5);
                    ctx.lineTo(0, 0); ctx.closePath(); ctx.fill(); ctx.restore();
                }
                if (this.health < this.maxHealth) {
                    const barWidth = this.size; const barHeight = 6;
                    const yOffset = this.size / 2 + 8;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                    ctx.strokeStyle = '#111';
                    ctx.strokeRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                }
                ctx.fillStyle = colors.player; ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ¦†', this.x, this.y);
            }
            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4;
            }
            update() {
                let speed = this.baseSpeed;
                if (weather.effect === 'speed') speed *= weather.value;
                let vx = 0; let vy = 0;
                
                // Updated: Check settings for movement keys
                if (settings.move === 'arrowkeys') {
                    if (keys['arrowup']) vy = -1;
                    if (keys['arrowdown']) vy = 1;
                    if (keys['arrowleft']) vx = -1;
                    if (keys['arrowright']) vx = 1;
                } else if (settings.move === 'wasd') {
                    if (keys['w']) vy = -1;
                    if (keys['s']) vy = 1;
                    if (keys['a']) vx = -1;
                    if (keys['d']) vx = 1;
                }
                
                if (vx !== 0 && vy !== 0) {
                    vx *= Math.SQRT1_2; vy *= Math.SQRT1_2;
                }
                const newX = this.x + vx * speed;
                const newY = this.y + vy * speed;
                if (!this.isColliding(newX, this.y)) this.x = newX;
                if (!this.isColliding(this.x, newY)) this.y = newY;
                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));
            }

            performAttack(angle) {
                const weapon = weapons[this.currentWeapon];
                let cooldown = weapon.cooldown;
                if (weather.effect === 'attackSpeed') cooldown *= weather.value;
                const now = Date.now();
                if (now - this.lastAttackTime < cooldown) return;
                
                this.lastAttackTime = now;
                this.isAttacking = true;
                clearTimeout(this.attackAnimTimeout);
                this.attackAnimTimeout = setTimeout(() => this.isAttacking = false, 100);

                this.attackAngle = angle; 

                // const targets = bosses.length > 0 ? bosses : enemies; // <-- This was the bug
                const targets = bosses.concat(enemies); // <-- This is the fix
                targets.forEach(target => {
                    const dist = getDistance(this, target);
                    if (dist < weapon.range + target.size / 2) { 
                        const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                        let angleDiff = Math.abs(this.attackAngle - angleToTarget);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                        
                        if (angleDiff < Math.PI / 2.5) { 
                            let damage = weapon.damage;
                            if (weather.effect === 'damage') damage *= weather.value;
                            target.takeDamage(damage);
                        }
                    }
                });
            }

            attack() {
                const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                this.performAttack(angle);
            }

            takeDamage(amount) {
                if (weather.effect === 'defense') amount *= weather.value;
                this.health -= Math.round(amount);
                if(this.health <= 0) {
                    this.health = 0;
                    if (isTestingLevel) {
                        showGUI("Test Over", "You were defeated.", "Return to Editor", enterEditorMode);
                    } else {
                        gameState = 'gameover';
                        // Updated death message
                        const deathMessage = currentChapter === 2 ? "The EUROPE forces were too strong!" : "The IMT Lazarus forces were too strong!";
                        showGUI("Game Over", deathMessage, "Try Again", resetGame);
                    }
                }
                updateUI();
            }
        }
        
        // --- Projectile Class (shared) ---
        class Projectile {
            constructor(x, y, angle, speed, damage, size, color, symbol) {
                this.x = x; this.y = y;
                this.angle = angle;
                this.speed = speed;
                this.damage = damage;
                this.size = size;
                this.color = color;
                this.symbol = symbol;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                if (getDistance(this, player) < player.size / 2) {
                    player.takeDamage(this.damage);
                    this.remove();
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x, this.y);
            }
            remove() {
                projectiles = projectiles.filter(p => p !== this);
            }
        }

        // --- Base Boss Class ---
        class Boss {
             constructor(x, y, size, health, symbol, color) {
                this.x = x; this.y = y; this.size = size;
                this.maxHealth = health; this.health = health;
                this.speed = 1;
                this.aggroRange = TILE_SIZE * 20; // Whole screen
                this.symbol = symbol; // <-- Added this
                this.color = color;   // <-- Added this
                this.isStomping = false; // For stomp anim
                this.stompAnimTimer = 0; // For stomp anim
            }
            draw() {
                let currentSize = this.size;
                if (this.isStomping && this.stompAnimTimer > 0) {
                    const animDuration = 500; // 500ms stomp anim
                    const progress = (animDuration - this.stompAnimTimer) / animDuration; // goes 0 to 1
                    const scale = 1 + Math.sin(progress * Math.PI) * 0.5; // pulses from 1 to 1.5 to 1
                    currentSize *= scale;
                }

                ctx.fillStyle = this.color || colors.boss; 
                ctx.font = `${currentSize}px sans-serif`; // Use currentSize
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                ctx.fillText(this.symbol, this.x, this.y);
                
                const barWidth = this.size * 1.5; const barHeight = 15; // Keep bar size consistent
                const yOffset = this.size / 2 + 15;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
            }
            isColliding(x, y) {
                 const tileX = Math.floor(x / TILE_SIZE);
                 const tileY = Math.floor(y / TILE_SIZE);
                 const tileType = map[tileY] ? map[tileY][tileX] : 1;
                 return tileType === 1 || tileType === 4;
            }
            baseUpdate() { // Common movement logic
                const dist = getDistance(this, player);
                if (dist > player.size) { // Move towards player
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const newX = this.x + Math.cos(angle) * this.speed;
                    const newY = this.y + Math.sin(angle) * this.speed;
                    if (!this.isColliding(newX, this.y)) this.x = newX;
                    if (!this.isColliding(this.x, newY)) this.y = newY;
                }
            }
             takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    bosses = bosses.filter(b => b !== this); // Remove this boss
                    checkLevelComplete();
                }
            }
            update() {
                this.baseUpdate();
            }
        }

        // --- Chapter 1 Boss ---
        class BossLazarus extends Boss {
            constructor(x, y) {
                super(x, y, TILE_SIZE * 3, 500, 'ðŸ”±', colors.boss); // Changed 'B' back to 'ðŸ”±'
                this.attackCooldown = 2000; this.lastAttackTime = Date.now();
            }
            update() {
                this.baseUpdate();
                const now = Date.now();
                if (now - this.lastAttackTime > this.attackCooldown) {
                    const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                    projectiles.push(new Projectile(this.x, this.y, angleToPlayer, 4, 10, TILE_SIZE * 0.5, colors.projectile, 'L'));
                    this.lastAttackTime = now;
                }
            }
        }
        
        // --- Chapter 2 Bosses ---
        class BossEiffelTower extends Boss {
            constructor(x, y) {
                super(x, y, TILE_SIZE * 4, 800, 'ðŸ—¼', colors.bossEurope); // Changed 'T' back to 'ðŸ—¼'
                this.attackCooldown = 1500; this.lastAttackTime = Date.now();
                this.stompCooldown = 2000; this.lastStompTime = Date.now();
                this.spawnEnemyCooldown = 8000; // New: 8 seconds
                this.lastSpawnEnemyTime = Date.now(); // New
                this.speed = 1.00;
                // isStomping and stompAnimTimer are inherited from Boss
            }
            update() {
                this.baseUpdate();
                if (this.isStomping) {
                    this.stompAnimTimer -= 16.67; // Assuming 60fps
                    if (this.stompAnimTimer <= 0) {
                        this.isStomping = false;
                    }
                }
                const now = Date.now();
                if (now - this.lastAttackTime > this.attackCooldown) { // Laser
                    const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                    projectiles.push(new Projectile(this.x, this.y, angleToPlayer, 7, 15, TILE_SIZE * 0.3, colors.projectileEurope, 'âš¡'));
                    projectiles.push(new Projectile(this.x, this.y, -angleToPlayer, 7, 15, TILE_SIZE * 0.3, colors.projectileEurope, 'âš¡'));

                    this.lastAttackTime = now;
                }
                if (now - this.lastStompTime > this.stompCooldown) { // Stomp
                    this.isStomping = true;
                    this.stompAnimTimer = 500; // 500ms animation
                    // AOE damage
                    if (getDistance(this, player) < TILE_SIZE * 4) {
                        player.takeDamage(25);
                    }
                    // Visual effect (handled in draw or a separate effect system, for now just damage)
                    this.lastStompTime = now;
                }
                
                // NEW: Spawn Enemies
                if (now - this.lastSpawnEnemyTime > this.spawnEnemyCooldown) {
                    const stats = enemyStats[chapterData[currentChapter].enemyClass] || enemyStats["Lazarus"];
                    // Spawn 2 enemies near the boss, ensuring they aren't in walls
                    const spawn1 = {x: this.x - TILE_SIZE * 2, y: this.y};
                    const spawn2 = {x: this.x + TILE_SIZE * 2, y: this.y};

                    if (!this.isColliding(spawn1.x, spawn1.y)) {
                        enemies.push(new Enemy(spawn1.x, spawn1.y, stats));
                    }
                    if (!this.isColliding(spawn2.x, spawn2.y)) {
                        enemies.push(new Enemy(spawn2.x, spawn2.y, stats));
                    }
                    
                    this.lastSpawnEnemyTime = now;
                }
            }
        }

        class BossBigBen extends Boss {
            constructor(x, y) {
                super(x, y, TILE_SIZE * 3.5, 700, 'ðŸ•°ï¸', colors.bossEurope); // Changed 'C' back to 'ðŸ•°ï¸'
                this.attackCooldown = 1500; this.lastAttackTime = Date.now();
                this.ringCooldown = 6000; this.lastRingTime = Date.now();
                this.speed = 0.6;
                this.projectileStartAngle = 0; // For rotating attack
            }
            update() {
                this.baseUpdate();
                const now = Date.now();
                if (now - this.lastAttackTime > this.attackCooldown) { // Spawn Gears
                    for(let i=0; i<6; i++) {
                        const angle = this.projectileStartAngle + (Math.PI / 3) * i; // Add the starting angle
                        projectiles.push(new Projectile(this.x, this.y, angle, 3, 1, TILE_SIZE * 0.6, colors.projectileEurope, 'âš™ï¸'));
                    }
                    this.projectileStartAngle += Math.PI / 12; // Rotate the launcher for next time
                    this.lastAttackTime = now;
                }
                if (now - this.lastRingTime > this.ringCooldown) { // Ring Bell
                    for(let i=0; i<8; i++) {
                        const angle = this.projectileStartAngle + (Math.PI / 4) * i; // Add the starting angle
                        projectiles.push(new Projectile(this.x, this.y, angle, 3, 1, TILE_SIZE * 0.6, colors.projectileEurope, 'âš™ï¸'));
                    }
                    
                    if (now - this.ringCooldown - this.lastRingTime > 1000) {this.lastRingTime = now}
                    this.projectileStartAngle += Math.PI / 8; // Rotate the launcher for next time
                    
                }
            }
        }

        // --- Base Enemy Class ---
        class Enemy {
            constructor(x, y, stats) {
                this.x = x; this.y = y; 
                this.size = TILE_SIZE * 0.8;
                this.maxHealth = stats.health;
                this.health = stats.health;
                this.speed = stats.speed;
                this.damage = stats.damage;
                this.symbol = stats.symbol;
                this.color = stats.color;
                this.attackCooldown = 1000; 
                this.lastAttackTime = 0; 
                this.aggroRange = TILE_SIZE * 6;
            }
            draw() {
                ctx.fillStyle = this.color; 
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                ctx.fillText(this.symbol, this.x, this.y);
                if (this.health < this.maxHealth) {
                    const barWidth = this.size; const barHeight = 5;
                    const yOffset = this.size / 2 + 5;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4;
            }
            update() {
                const dist = getDistance(this, player);
                if (dist < this.aggroRange && dist > player.size / 2) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const newX = this.x + Math.cos(angle) * this.speed;
                    const newY = this.y + Math.sin(angle) * this.speed;
                    if (!this.isColliding(newX, this.y)) this.x = newX;
                    if (!this.isColliding(this.x, newY)) this.y = newY;
                }
                if (dist < player.size / 2 + 5) {
                     const now = Date.now();
                     if (now - this.lastAttackTime > this.attackCooldown) {
                         player.takeDamage(this.damage);
                         this.lastAttackTime = now;
                     }
                }
            }
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    enemies = enemies.filter(e => e !== this);
                    checkLevelComplete();
                }
            }
        }
        
        // --- Enemy Stat Blocks ---
        const enemyStats = {
            "Lazarus": {
                health: 30, speed: 1.5, damage: 5,
                symbol: 'L', color: colors.enemy
            },
            "Europe": {
                health: 50, speed: 1.8, damage: 8,
                symbol: 'E', color: colors.enemyEurope
            }
        };

        // --- Game Setup and Loop ---
        function loadLevel() {
            const chap = chapterData[currentChapter];
            const level = chap.levels[currentLevel];
            map = level.map.map(row => row.split('').map(Number));
            
            player = player || new Player(0,0);
            
            const spawn = findValidSpawnPoint();
            player.x = spawn.x;
            player.y = spawn.y;
            
            enemies = [];
            projectiles = [];
            bosses = []; // Use plural `bosses` array

            if (level.boss) {
                // Centered spawn point for bosses, inside the map area
                const spawnPoint = {x: (map[0].length / 2) * TILE_SIZE, y: (map.length / 2) * TILE_SIZE};
                if (level.boss === "Lazarus") {
                    bosses.push(new BossLazarus(spawnPoint.x, spawnPoint.y));
                } else if (level.boss === "BigBen") {
                    bosses.push(new BossBigBen(spawnPoint.x, spawnPoint.y));
                } else if (level.boss === "EiffelTower") {
                    bosses.push(new BossEiffelTower(spawnPoint.x, spawnPoint.y));
                }
            } else {
                 const enemyCount = level.enemyCount;
                 const stats = enemyStats[chap.enemyClass] || enemyStats["Lazarus"];
                 for (let i = 0; i < enemyCount; i++) {
                    const spawnPoint = findValidSpawnPoint();
                    enemies.push(new Enemy(spawnPoint.x, spawnPoint.y, stats));
                }
            }
            updateUI();
        }

        function checkLevelComplete() {
            if (gameState !== 'playing') return;
            
            const levelCleared = enemies.length === 0 && bosses.length === 0;

            if (levelCleared) {
                const chap = chapterData[currentChapter];
                if (isTestingLevel) {
                    showGUI("Test Complete!", "You defeated all the test enemies.", "Return to Editor", enterEditorMode);
                    return;
                }
                
                // -2 to account for 0-index and custom level
                if (currentLevel < chap.levels.length - 2) { 
                    gameState = 'levelup';
                    showGUI("Level Complete!", `You cleared ${chap.levels[currentLevel].name}.`, "Next Level", () => {
                        currentLevel++;
                        loadLevel();
                        guiMessage.classList.add('hidden');
                        gameState = 'playing';
                    });
                } else {
                    gameState = 'gameover'; // Set state to prevent timer from running
                    // Updated win message
                    const winMessage = currentChapter === 2 ? "You have defeated the EUROPE conspiracy!" : "You have defeated the IMT Lazarus army!";
                    showGUI("You Win!", winMessage, "Play Again", resetGame);
                }
            }
        }

        function skipLevel() {
            if (gameState !== 'playing' || isTestingLevel) return; // Don't allow skipping in test mode

            const chap = chapterData[currentChapter];
            
            // -2 to account for 0-index and custom level
            if (currentLevel < chap.levels.length - 2) { 
                currentLevel++;
                loadLevel();
            } else {
                // At the final boss level, skipping wins the game
                gameState = 'gameover'; 
                // Updated win message
                const winMessage = currentChapter === 2 ? "You have defeated the EUROPE conspiracy!" : "You have defeated the IMT Lazarus army!";
                showGUI("You Win!", winMessage, "Play Again", resetGame);
            }
        }

        function startGame(isTest = false) {
            isTestingLevel = isTest;
            gameState = 'playing';
            guiMenuCh1.classList.add('hidden');
            guiMenuCh2.classList.add('hidden');
            guiEditor.classList.add('hidden');
            guiPause.classList.add('hidden');
            guiSettings.classList.add('hidden');
            uiPanel.classList.remove('hidden');
            
            player = new Player(TILE_SIZE * 2, TILE_SIZE * 2);

            // Set health based on chapter
            if (currentChapter === 2) {
                player.maxHealth = 350;
                player.health = 350;
            } else {
                player.maxHealth = 100;
                player.health = 100;
            }

            weapons = chapterData[currentChapter].weapons;
            
            if (!isTest) {
                startTime = Date.now();
                timerUI.classList.remove('hidden');
            } else {
                timerUI.classList.add('hidden');
            }
            
            currentLevel = 0;
            setupWeather();
            setupWeapons();
            loadLevel();

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function resetGame() {
            cancelAnimationFrame(gameLoopId);
            clearInterval(weatherInterval);
            currentLevel = 0;
            guiMessage.classList.add('hidden');
            guiPause.classList.add('hidden');
            startGame();
        }
        
        // --- Editor Functions ---
        function enterEditorMode() {
            isTestingLevel = false;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameState = 'editor';
            
            // Hide all other UI
            guiMenuCh1.classList.add('hidden');
            guiMenuCh2.classList.add('hidden');
            guiMessage.classList.add('hidden');
            uiPanel.classList.add('hidden');
            guiPause.classList.add('hidden');
            guiSettings.classList.add('hidden');

            // Show editor
            guiEditor.classList.remove('hidden');
            
            // Load custom map for editing
            const chap = chapterData[currentChapter];
            const customLevelIndex = chap.levels.length - 1;
            map = chap.levels[customLevelIndex].map.map(row => row.split('').map(Number));
            
            // Start a simple render loop for the editor
            gameLoopId = requestAnimationFrame(editorLoop);
        }
        
        function setupEditor() {
            tilePalette.innerHTML = ''; // Clear palette
            Object.entries(colors.tiles).forEach(([id, color]) => {
                const tileDiv = document.createElement('div');
                tileDiv.className = 'tile-palette-item';
                tileDiv.style.backgroundColor = color;
                tileDiv.dataset.tileId = id;
                if (id == editorBrush) tileDiv.classList.add('selected');
                tileDiv.onclick = () => {
                    editorBrush = parseInt(id);
                    document.querySelectorAll('.tile-palette-item').forEach(d => d.classList.remove('selected'));
                    tileDiv.classList.add('selected');
                };
                tilePalette.appendChild(tileDiv);
            });
        }
        
        function paintTile(e, isRightClick = false) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const tileX = Math.floor(mouseX / TILE_SIZE);
            const tileY = Math.floor(mouseY / TILE_SIZE);

            if (map[tileY] && map[tileY][tileX] !== undefined) {
                // Prevent drawing over border walls
                if(tileX > 0 && tileX < map[0].length-1 && tileY > 0 && tileY < map.length -1){
                    map[tileY][tileX] = isRightClick ? 0 : editorBrush; // Right click erases to grass
                }
            }
        }
        
        function editorLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            gameLoopId = requestAnimationFrame(editorLoop);
        }

        // --- Pause Functions ---
        function pauseGame() {
            if (gameState !== 'playing') return;
            gameState = 'paused';
            guiPause.classList.remove('hidden');
        }

        function resumeGame() {
            if (gameState !== 'paused') return;
            gameState = 'playing';
            guiPause.classList.add('hidden');
            guiMessage.classList.add('hidden'); // Also close any level-up messages
        }

        function returnToMenu() {
            cancelAnimationFrame(gameLoopId);
            clearInterval(weatherInterval);
            guiPause.classList.add('hidden');
            uiPanel.classList.add('hidden');
            guiMessage.classList.add('hidden');
            guiEditor.classList.add('hidden');
            guiSettings.classList.add('hidden');
            
            if (currentChapter === 1) {
                guiMenuCh1.classList.remove('hidden');
                gameState = 'menu-ch1';
            } else {
                guiMenuCh2.classList.remove('hidden');
                gameState = 'menu-ch2';
            }
        }

        function updateUI() {
            if (!player) return;
            healthUI.textContent = player.health;
            levelUI.textContent = isTestingLevel ? "Test" : currentLevel + 1;

            if (bosses.length > 0) {
                const boss = bosses[0]; // Show health of first boss
                enemiesLabelUI.textContent = "Boss Health:";
                enemiesLeftUI.textContent = `${boss.health}/${boss.maxHealth}`;
                enemiesLeftUI.className = 'text-purple-400';
            } else {
                enemiesLabelUI.textContent = "Enemies:";
                enemiesLeftUI.textContent = enemies.length;
                enemiesLeftUI.className = 'text-red-400';
            }

            weatherUI.textContent = weather.name;
            weatherUI.style.color = weather.color;
        }

        function setupWeather() {
            let currentTimer = 20;
            weather = weatherTypes[0];
            weatherTimerUI.textContent = currentTimer;
            if(weatherInterval) clearInterval(weatherInterval);
            weatherInterval = setInterval(() => {
                if (gameState !== 'playing') return;
                currentTimer--;
                if (currentTimer <= 0) {
                    currentTimer = 20;
                    const newIndex = Math.floor(Math.random() * weatherTypes.length);
                    weather = weatherTypes[newIndex];
                    updateUI();
                }
                weatherTimerUI.textContent = currentTimer;
            }, 1000);
        }
        
        function setupWeapons() {
            weaponSelectUI.innerHTML = '';
            weapons.forEach((weapon, index) => {
                const btn = document.createElement('button');
                btn.className = `weapon-btn p-2 rounded`;
                btn.textContent = `${weapon.name} (${weapon.damage} Dmg)`;
                btn.onclick = () => {
                    player.currentWeapon = index;
                    document.querySelectorAll('.weapon-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                weaponSelectUI.appendChild(btn);
            });
            weaponSelectUI.children[0].classList.add('active');
        }

        function drawMap() {
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    ctx.fillStyle = colors.tiles[map[y][x]] || 'black';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        
        function gameLoop() {
            if (gameState === 'playing') {
                player.update();
                enemies.forEach(enemy => enemy.update());
                bosses.forEach(boss => boss.update());
                
                projectiles.forEach(p => p.update());
                projectiles = projectiles.filter(p => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height);
                
                if(!isTestingLevel) updateTimer();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            projectiles.forEach(p => p.draw());
            enemies.forEach(enemy => enemy.draw());
            bosses.forEach(boss => boss.draw());
            if (player) player.draw();
            updateUI();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        
        // Chapter 1 Menu
        startButtonCh1.addEventListener('click', () => { currentChapter = 1; startGame(false); });
        editorButtonCh1.addEventListener('click', () => { currentChapter = 1; lastMenuState = 'menu-ch1'; enterEditorMode(); });
        settingsButtonCh1.addEventListener('click', () => {
            lastMenuState = 'menu-ch1';
            guiMenuCh1.classList.add('hidden');
            guiSettings.classList.remove('hidden');
        });
        gotoCh2Button.addEventListener('click', () => {
            guiMenuCh1.classList.add('hidden');
            guiMenuCh2.classList.remove('hidden');
            gameState = 'menu-ch2';
        });

        // Chapter 2 Menu
        startButtonCh2.addEventListener('click', () => { currentChapter = 2; startGame(false); });
        editorButtonCh2.addEventListener('click', () => { currentChapter = 2; lastMenuState = 'menu-ch2'; enterEditorMode(); });
        settingsButtonCh2.addEventListener('click', () => {
            lastMenuState = 'menu-ch2';
            guiMenuCh2.classList.add('hidden');
            guiSettings.classList.remove('hidden');
        });
        gotoCh1Button.addEventListener('click', () => {
            guiMenuCh2.classList.add('hidden');
            guiMenuCh1.classList.remove('hidden');
            gameState = 'menu-ch1';
        });
        
        // --- Settings Listeners ---
        settingsBackButton.addEventListener('click', () => {
            guiSettings.classList.add('hidden');
            if (lastMenuState === 'menu-ch1') {
                guiMenuCh1.classList.remove('hidden');
                gameState = 'menu-ch1';
            } else {
                guiMenuCh2.classList.remove('hidden');
                gameState = 'menu-ch2';
            }
        });

        function updateAttackSetting(newSetting) {
            settings.attack = newSetting;
            attackSettingButtons.forEach(btn => btn.classList.remove('active'));
            if (newSetting === 'mouse') settingAttackMouse.classList.add('active');
            if (newSetting === 'arrowkeys') settingAttackArrows.classList.add('active');
            if (newSetting === 'wasd') settingAttackWasd.classList.add('active');
        }

        settingAttackMouse.addEventListener('click', () => updateAttackSetting('mouse'));
        settingAttackArrows.addEventListener('click', () => updateAttackSetting('arrowkeys'));
        settingAttackWasd.addEventListener('click', () => updateAttackSetting('wasd'));
        
        // New Move Settings Listeners
        settingMoveArrows.addEventListener('click', () => updateMoveSetting('arrowkeys'));
        settingMoveWasd.addEventListener('click', () => updateMoveSetting('wasd'));

        function updateMoveSetting(newSetting) {
            settings.move = newSetting;
            moveSettingButtons.forEach(btn => btn.classList.remove('active'));
            if (newSetting === 'arrowkeys') settingMoveArrows.classList.add('active');
            if (newSetting === 'wasd') settingMoveWasd.classList.add('active');
        }

        // --- End New Settings Listeners ---

        exitEditorBtn.addEventListener('click', () => {
             cancelAnimationFrame(gameLoopId);
             guiEditor.classList.add('hidden');
             if (lastMenuState === 'menu-ch1') {
                guiMenuCh1.classList.remove('hidden');
                gameState = 'menu-ch1';
             } else {
                guiMenuCh2.classList.remove('hidden');
                gameState = 'menu-ch2';
             }
        });

        testLevelBtn.addEventListener('click', () => {
            const chap = chapterData[currentChapter];
            currentLevel = chap.levels.length - 1; // Always test the custom level
            startGame(true);
        });

        copyLevelBtn.addEventListener('click', () => {
            const mapStrings = map.map(row => row.join(''));
            levelDataTextarea.value = JSON.stringify(mapStrings, null, 2);
            levelDataTextarea.select();
            try { document.execCommand('copy'); } catch(e) { console.error("Copy failed", e); }
        });

        pasteLevelBtn.addEventListener('click', () => {
             try {
                const chap = chapterData[currentChapter];
                const customLevelIndex = chap.levels.length - 1;
                const mapStrings = JSON.parse(levelDataTextarea.value);
                if (Array.isArray(mapStrings) && mapStrings.length === chap.levels[customLevelIndex].map.length) {
                    const newMapLayout = mapStrings.map(row => row.split('').map(Number));
                    chap.levels[customLevelIndex].map = newMapLayout.map(row => row.join('')); // Store as strings
                    map = newMapLayout; // Update the currently edited map
                } else {
                    console.error('Invalid map data format!');
                }
             } catch(e) {
                console.error('Could not parse map data. Make sure it is valid JSON.', e);
             }
        });
        
        // --- General Listeners ---
        resumeButton.addEventListener('click', resumeGame);
        mainMenuButton.addEventListener('click', returnToMenu);

        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();

            if (gameState === 'playing') {
                // --- Attack Logic ---
                if (settings.attack === 'arrowkeys') {
                    if (key === 'arrowup') { e.preventDefault(); player.performAttack(-Math.PI / 2); }
                    if (key === 'arrowdown') { e.preventDefault(); player.performAttack(Math.PI / 2); }
                    if (key === 'arrowleft') { e.preventDefault(); player.performAttack(Math.PI); }
                    if (key === 'arrowright') { e.preventDefault(); player.performAttack(0); }
                } else if (settings.attack === 'wasd') {
                    if (key === 'w') { e.preventDefault(); player.performAttack(-Math.PI / 2); }
                    if (key === 's') { e.preventDefault(); player.performAttack(Math.PI / 2); }
                    if (key === 'a') { e.preventDefault(); player.performAttack(Math.PI); }
                    if (key === 'd') { e.preventDefault(); player.performAttack(0); }
                    
                    // If move keys are arrows, we should return after a WASD attack
                    if (settings.move === 'arrowkeys' && (key === 'w' || key === 's' || key === 'a' || key === 'd')) {
                        return;
                    }
                }

                // --- REMOVED Cheat Key ---
            }

            // --- Movement & General Keys ---
            keys[key] = true;

            // --- Pause Key ---
            if (key === 'escape') {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused' && !guiMessage.classList.contains('hidden')) {
                    // Don't unpause if a message is shown
                } else if (gameState === 'paused') {
                    resumeGame();
                }
            }
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault()); // Prevent right-click menu

        canvas.addEventListener('mousedown', e => {
            if (gameState === 'editor') {
                mouse.down = true;
                paintTile(e, e.button === 2); // Pass true if right-click
            }
            if (gameState === 'playing' && settings.attack === 'mouse') { 
                player.attack();
            }
        });
        
        canvas.addEventListener('mouseup', e => {
            if (gameState === 'editor') mouse.down = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            if (gameState === 'editor' && mouse.down) {
                paintTile(e, e.buttons === 2);
            }
        });
        
        setupEditor(); // Init palette
    </script>
</body>
</html>
