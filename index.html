<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Weather RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden;
        }
        canvas {
            background-color: #162447;
            cursor: crosshair;
            border-radius: 0.5rem;
            border: 4px solid #1f4068;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
        }
        .ui-panel {
            background-color: rgba(0,0,0,0.5);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
        }
        .weapon-btn {
            background-color: #4a5568;
            border: 2px solid #2d3748;
            transition: all 0.2s;
        }
        .weapon-btn.active {
            background-color: #a0aec0;
            border-color: #718096;
            transform: scale(1.1);
        }
        .hidden {
            display: none;
        }
        .gui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        .gui-button {
            padding: 0.75rem 2rem;
            font-size: 1.25rem;
            color: #1a1a2e;
            background-color: #6ee7b7;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        .gui-button:hover {
            transform: scale(1.05);
            background-color: #86efac;
        }
    </style>
</head>
<body>
    <div id="game-container" class="game-container relative">
        <canvas id="gameCanvas" width="960" height="540"></canvas>
        
        <div id="ui-panel" class="ui-panel mt-4 w-full max-w-4xl text-sm hidden">
            <div class="flex justify-between items-center">
                <div>
                    Health: <span id="health" class="text-green-400">100</span> | 
                    Level: <span id="level" class="text-yellow-300">1</span> |
                    <span id="enemies-label">Enemies:</span> <span id="enemies-left" class="text-red-400">0</span>
                </div>
                 <div>Timer: <span id="timer" class="text-white">00:00:000</span></div>
                <div>Weather: <span id="weather" class="text-cyan-300">Clear</span> (<span id="weather-timer" class="text-cyan-300">20</span>s)</div>
            </div>
            <div id="weapon-select" class="flex justify-center gap-4 mt-2">
                <!-- Weapon buttons will be generated here -->
            </div>
        </div>

        <!-- GUI Overlays -->
        <div id="gui-menu" class="gui-overlay">
            <h1 class="text-5xl text-yellow-300 mb-4">Duck Weather RPG</h1>
            <p class="text-lg text-gray-300 mb-8 max-w-md">The IMT Lazarus army fears only two things: ducks and unpredictable weather.</p>
            <button id="start-button" class="gui-button">Start Adventure</button>
        </div>

        <div id="gui-message" class="gui-overlay hidden">
            <h2 id="message-title" class="text-4xl mb-4"></h2>
            <p id="message-text" class="text-lg mb-8"></p>
            <button id="message-button" class="gui-button"></button>
        </div>
    </div>

    <script>
        // --- Canvas and UI Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        const healthUI = document.getElementById('health');
        const levelUI = document.getElementById('level');
        const enemiesLabelUI = document.getElementById('enemies-label');
        const enemiesLeftUI = document.getElementById('enemies-left');
        const weatherUI = document.getElementById('weather');
        const weatherTimerUI = document.getElementById('weather-timer');
        const weaponSelectUI = document.getElementById('weapon-select');
        const timerUI = document.getElementById('timer');
        
        const guiMenu = document.getElementById('gui-menu');
        const startButton = document.getElementById('start-button');
        const guiMessage = document.getElementById('gui-message');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');

        // --- Game Constants ---
        const TILE_SIZE = 40;
        const PLAYER_SPEED = 3.5;
        const colors = {
            player: 'yellow',
            enemy: '#f87171', // red-400
            boss: '#e11d48', // rose-600
            projectile: '#f43f5e', // rose-500
            attack: 'rgba(255, 255, 255, 0.3)',
            tiles: {
                0: '#4ade80', // green-400 (grass)
                1: '#78716c', // stone-500 (rock/wall)
                2: '#a16207', // yellow-700 (path)
                3: '#4338ca', // indigo-700 (cave floor)
                4: '#2563eb', // blue-600 (water)
                5: '#a3a3a3', // neutral-400 (castle floor)
                6: '#dc2626', // red-600 (boss floor)
            }
        };

        // --- Game State ---
        let player, enemies = [], projectiles = [], boss, map, weapons, weather, weatherInterval, gameLoopId;
        let keys = {};
        let currentLevel = 0;
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'levelup', 'gameover'
        let mouse = { x: 0, y: 0 };
        let startTime = 0;
        let finalTime = "00:00:000";

        // --- Game Data ---
        const levels = [
            // ... (level 1, 2, 3 data remains the same)
            {
                name: "The Sunny Plains",
                enemyCount: 5,
                map: [
                    "111111111111111111111111", "100022200000004444000001", "100220020000044444400001", "102200002220004440000001", "100000000022000000002201", "100000000002222222222001", "111111111111111111111111",
                ]
            },
            {
                name: "The Dank Cave",
                enemyCount: 8,
                map: [
                    "111111111111111111111111", "133313333333333331333331", "134431333111331113334431", "13443133333133133334431", "133331113331331333333331", "133333333333333333333331", "111111111111111111111111",
                ]
            },
            {
                name: "Lazarus's Keep",
                enemyCount: 10,
                map: [
                    "111111111111111111111111", "155555555555555555555551", "151115511155111551115511", "155555555555555555555551", "115511155111551115511155", "155555555555555555555551", "111111111111111111111111",
                ]
            },
            {
                name: "Throne of Lazarus",
                enemyCount: 1, // Special flag for boss level
                map: [
                    "111111111111111111111111",
                    "166666666666666666666661",
                    "166661111111111111166661",
                    "166661666666666666166661",
                    "166661111111111111166661",
                    "166666666666666666666661",
                    "111111111111111111111111",
                ]
            }
        ];
        
        const mapLayout = levels.map(level => level.map.map(row => row.split('').map(Number)));

        const weaponsConfig = [
            { name: "Broadsword", damage: 12, range: TILE_SIZE * 1.5, cooldown: 500 },
            { name: "Dagger", damage: 8, range: TILE_SIZE * 0.9, cooldown: 250 },
            { name: "Greatsword", damage: 20, range: TILE_SIZE * 2.2, cooldown: 900 },
        ];
        
        const weatherTypes = [
            { name: "Sunny", effect: "speed", value: 1.2, color: "#fcd34d" },
            { name: "Rainy", effect: "defense", value: 0.75, color: "#60a5fa" },
            { name: "Windy", effect: "attackSpeed", value: 0.8, color: "#9ca3af" },
            { name: "Stormy", effect: "damage", value: 1.5, color: "#a78bfa" },
        ];
        
        // --- Utility Functions ---
        function getDistance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function findValidSpawnPoint() {
            let x, y, tileX, tileY, tileType;
            const padding = TILE_SIZE; 
            do {
                x = Math.random() * (canvas.width - padding * 2) + padding;
                y = Math.random() * (canvas.height - padding * 2) + padding;
                tileX = Math.floor(x / TILE_SIZE);
                tileY = Math.floor(y / TILE_SIZE);
                tileType = (map[tileY] && map[tileY][tileX] !== undefined) ? map[tileY][tileX] : 1;
            } while (tileType === 1 || tileType === 4); 
            return { x, y };
        }
        
        function showGUI(title, text, buttonText, callback) {
            gameState = 'paused';
            messageTitle.textContent = title;
            if (title === "You Win!" || title === "Game Over") {
                 messageText.textContent = `${text} Your time: ${finalTime}`;
            } else {
                messageText.textContent = text;
            }
            messageButton.textContent = buttonText;
            messageButton.onclick = callback;
            guiMessage.classList.remove('hidden');
        }
        
        function updateTimer() {
            if (gameState !== 'playing') return;
            const elapsed = Date.now() - startTime;
            const minutes = String(Math.floor(elapsed / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsed % 60000) / 1000)).padStart(2, '0');
            const milliseconds = String(elapsed % 1000).padStart(3, '0');
            finalTime = `${minutes}:${seconds}:${milliseconds}`;
            timerUI.textContent = finalTime;
        }

        // --- Game Object Classes ---
        class Player {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = TILE_SIZE;
                this.maxHealth = 100;
                this.health = 100;
                this.baseSpeed = PLAYER_SPEED;
                this.currentWeapon = 0;
                this.lastAttackTime = 0;
                this.isAttacking = false;
                this.attackAnimTimeout = null;
                this.attackAngle = 0; // Fixed: Added attackAngle property
            }
            draw() {
                if (this.isAttacking) {
                    const weapon = weapons[this.currentWeapon];
                    ctx.save(); ctx.beginPath(); ctx.translate(this.x, this.y);
                    ctx.rotate(this.attackAngle); // Use the player's attackAngle
                    ctx.fillStyle = colors.attack; ctx.globalAlpha = 0.6;
                    ctx.arc(weapon.range / 2, 0, weapon.range / 2, -Math.PI/2.5, Math.PI/2.5);
                    ctx.lineTo(0, 0); ctx.closePath(); ctx.fill(); ctx.restore();
                }
                if (this.health < this.maxHealth) {
                    const barWidth = this.size; const barHeight = 6;
                    const yOffset = this.size / 2 + 8;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                    ctx.strokeStyle = '#111';
                    ctx.strokeRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                }
                ctx.fillStyle = colors.player; ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ¦†', this.x, this.y);
            }
            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4;
            }
            update() {
                let speed = this.baseSpeed;
                if (weather.effect === 'speed') speed *= weather.value;
                let vx = 0; let vy = 0;
                if (keys['w'] || keys['arrowup']) vy = -1;
                if (keys['s'] || keys['arrowdown']) vy = 1;
                if (keys['a'] || keys['arrowleft']) vx = -1;
                if (keys['d'] || keys['arrowright']) vx = 1;
                if (vx !== 0 && vy !== 0) {
                    vx *= Math.SQRT1_2; vy *= Math.SQRT1_2;
                }
                const newX = this.x + vx * speed;
                const newY = this.y + vy * speed;
                if (!this.isColliding(newX, this.y)) this.x = newX;
                if (!this.isColliding(this.x, newY)) this.y = newY;
                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));
            }
            attack() {
                const weapon = weapons[this.currentWeapon];
                let cooldown = weapon.cooldown;
                if (weather.effect === 'attackSpeed') cooldown *= weather.value;
                const now = Date.now();
                if (now - this.lastAttackTime < cooldown) return;
                
                this.lastAttackTime = now;
                this.isAttacking = true;
                clearTimeout(this.attackAnimTimeout);
                this.attackAnimTimeout = setTimeout(() => this.isAttacking = false, 100);

                this.attackAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x); // Fixed: Set the player's attack angle

                // Damage enemies or boss
                const targets = boss ? [boss] : enemies;
                targets.forEach(target => {
                    const dist = getDistance(this, target);
                    if (dist < weapon.range + target.size / 2) { // More generous hit detection
                        const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                        let angleDiff = Math.abs(this.attackAngle - angleToTarget);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; // Handle angle wrapping
                        
                        if (angleDiff < Math.PI / 2.5) { // Wider attack arc
                            let damage = weapon.damage;
                            if (weather.effect === 'damage') damage *= weather.value;
                            target.takeDamage(damage);
                        }
                    }
                });
            }
            takeDamage(amount) {
                if (weather.effect === 'defense') amount *= weather.value;
                this.health -= Math.round(amount);
                if(this.health <= 0) {
                    this.health = 0;
                    gameState = 'gameover';
                    showGUI("Game Over", "The IMT Lazarus forces were too strong!", "Try Again", resetGame);
                }
                updateUI();
            }
        }
        
        class MiniLazarus {
            constructor(x, y, angle) {
                this.x = x; this.y = y;
                this.size = TILE_SIZE * 0.5;
                this.speed = 4;
                this.damage = 10;
                this.angle = angle;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                if (getDistance(this, player) < player.size / 2) {
                    player.takeDamage(this.damage);
                    this.remove();
                }
            }
            draw() {
                ctx.fillStyle = colors.projectile;
                ctx.font = `${this.size}px sans-serif`;
                ctx.fillText('L', this.x, this.y);
            }
            remove() {
                projectiles = projectiles.filter(p => p !== this);
            }
        }

        class Boss {
             constructor(x, y) {
                this.x = x; this.y = y; this.size = TILE_SIZE * 3;
                this.maxHealth = 500;
                this.health = 500;
                this.speed = 1;
                this.damage = 20; // Contact damage
                this.attackCooldown = 2000; this.lastAttackTime = Date.now();
                this.aggroRange = TILE_SIZE * 20; // Whole screen
            }
            draw() {
                ctx.fillStyle = colors.boss; ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ”±', this.x, this.y);
                const barWidth = this.size * 1.5; const barHeight = 15;
                const yOffset = this.size / 2 + 15;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
            }
            isColliding(x, y) {
                 const tileX = Math.floor(x / TILE_SIZE);
                 const tileY = Math.floor(y / TILE_SIZE);
                 const tileType = map[tileY] ? map[tileY][tileX] : 1;
                 return tileType === 1 || tileType === 4;
            }
            update() {
                const dist = getDistance(this, player);
                if (dist > player.size) { // Move towards player
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const newX = this.x + Math.cos(angle) * this.speed;
                    const newY = this.y + Math.sin(angle) * this.speed;
                    if (!this.isColliding(newX, this.y)) this.x = newX;
                    if (!this.isColliding(this.x, newY)) this.y = newY;
                }
                
                // Shoot projectiles
                const now = Date.now();
                if (now - this.lastAttackTime > this.attackCooldown) {
                    const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                    projectiles.push(new MiniLazarus(this.x, this.y, angleToPlayer));
                    this.lastAttackTime = now;
                }
            }
             takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    boss = null; // Boss is defeated
                    checkLevelComplete();
                }
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = TILE_SIZE * 0.8;
                this.maxHealth = 30 + (currentLevel * 10);
                this.health = this.maxHealth;
                this.speed = 1.5 + (currentLevel * 0.2);
                this.damage = 5 + (currentLevel * 2);
                this.attackCooldown = 1000; this.lastAttackTime = 0; this.aggroRange = TILE_SIZE * 6;
            }
            draw() {
                ctx.fillStyle = colors.enemy; ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('L', this.x, this.y);
                if (this.health < this.maxHealth) {
                    const barWidth = this.size; const barHeight = 5;
                    const yOffset = this.size / 2 + 5;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth, barHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - barWidth / 2, this.y - yOffset, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            isColliding(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileType = map[tileY] ? map[tileY][tileX] : 1;
                return tileType === 1 || tileType === 4;
            }
            update() {
                const dist = getDistance(this, player);
                if (dist < this.aggroRange && dist > player.size / 2) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const newX = this.x + Math.cos(angle) * this.speed;
                    const newY = this.y + Math.sin(angle) * this.speed;
                    if (!this.isColliding(newX, this.y)) this.x = newX;
                    if (!this.isColliding(this.x, newY)) this.y = newY;
                }
                if (dist < player.size / 2 + 5) {
                     const now = Date.now();
                     if (now - this.lastAttackTime > this.attackCooldown) {
                         player.takeDamage(this.damage);
                         this.lastAttackTime = now;
                     }
                }
            }
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    enemies = enemies.filter(e => e !== this);
                    checkLevelComplete();
                }
            }
        }

        // --- Game Setup and Loop ---
        function loadLevel() {
            map = mapLayout[currentLevel];
            
            // Set player spawn point based on level to ensure they don't start in a wall
            if (currentLevel === 0) { // Plains
                 player.x = TILE_SIZE * 2;
                 player.y = TILE_SIZE * 2;
            } else if (currentLevel === 1 || currentLevel === 2) { // Cave & Keep
                 player.x = TILE_SIZE * 1.5;
                 player.y = TILE_SIZE * 1.5;
            } else if (currentLevel === 3) { // Boss
                 player.x = TILE_SIZE * 3;
                 player.y = TILE_SIZE * 3.5;
            }

            enemies = [];
            projectiles = [];
            boss = null;

            if (currentLevel === levels.length - 1) { // It's the boss level
                boss = new Boss(canvas.width * 0.75, canvas.height / 2);
            } else {
                 for (let i = 0; i < levels[currentLevel].enemyCount; i++) {
                    const spawnPoint = findValidSpawnPoint();
                    enemies.push(new Enemy(spawnPoint.x, spawnPoint.y));
                }
            }
            updateUI();
        }

        function checkLevelComplete() {
            if (gameState !== 'playing') return;
            
            const levelCleared = enemies.length === 0 && !boss;

            if (levelCleared) {
                if (currentLevel < levels.length - 1) {
                    gameState = 'levelup';
                    showGUI("Level Complete!", `You cleared ${levels[currentLevel].name}.`, "Next Level", () => {
                        currentLevel++;
                        loadLevel();
                        guiMessage.classList.add('hidden');
                        gameState = 'playing';
                    });
                } else {
                    gameState = 'gameover'; // Set state to prevent timer from running
                    showGUI("You Win!", "You have defeated the IMT Lazarus army!", "Play Again", resetGame);
                }
            }
        }

        function startGame() {
            gameState = 'playing';
            guiMenu.classList.add('hidden');
            uiPanel.classList.remove('hidden');
            
            player = new Player(TILE_SIZE * 2, TILE_SIZE * 2);
            weapons = weaponsConfig;
            
            startTime = Date.now();
            setupWeather();
            setupWeapons();
            loadLevel();

            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function resetGame() {
            cancelAnimationFrame(gameLoopId);
            clearInterval(weatherInterval);
            currentLevel = 0;
            guiMessage.classList.add('hidden');
            startGame();
        }

        function updateUI() {
            if (!player) return;
            healthUI.textContent = player.health;
            levelUI.textContent = currentLevel + 1;

            if (boss) {
                enemiesLabelUI.textContent = "Boss Health:";
                enemiesLeftUI.textContent = `${boss.health}/${boss.maxHealth}`;
                enemiesLeftUI.className = 'text-purple-400';
            } else {
                enemiesLabelUI.textContent = "Enemies:";
                enemiesLeftUI.textContent = enemies.length;
                enemiesLeftUI.className = 'text-red-400';
            }

            weatherUI.textContent = weather.name;
            weatherUI.style.color = weather.color;
        }

        function setupWeather() {
            let currentTimer = 20;
            weather = weatherTypes[0];
            weatherTimerUI.textContent = currentTimer;
            if(weatherInterval) clearInterval(weatherInterval);
            weatherInterval = setInterval(() => {
                if (gameState !== 'playing') return;
                currentTimer--;
                if (currentTimer <= 0) {
                    currentTimer = 20;
                    const newIndex = Math.floor(Math.random() * weatherTypes.length);
                    weather = weatherTypes[newIndex];
                    updateUI();
                }
                weatherTimerUI.textContent = currentTimer;
            }, 1000);
        }
        
        function setupWeapons() {
            weaponSelectUI.innerHTML = '';
            weapons.forEach((weapon, index) => {
                const btn = document.createElement('button');
                btn.className = `weapon-btn p-2 rounded`;
                btn.textContent = `${weapon.name} (${weapon.damage} Dmg)`;
                btn.onclick = () => {
                    player.currentWeapon = index;
                    document.querySelectorAll('.weapon-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                weaponSelectUI.appendChild(btn);
            });
            weaponSelectUI.children[0].classList.add('active');
        }

        function drawMap() {
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    ctx.fillStyle = colors.tiles[map[y][x]] || 'black';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        
        function gameLoop() {
            if (gameState === 'playing') {
                player.update();
                enemies.forEach(enemy => enemy.update());
                if (boss) boss.update();
                
                // Update and filter out projectiles that are off-screen
                projectiles.forEach(p => p.update());
                projectiles = projectiles.filter(p => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height);
                
                updateTimer();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            projectiles.forEach(p => p.draw());
            enemies.forEach(enemy => enemy.draw());
            if (boss) boss.draw();
            player.draw();
            updateUI();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        canvas.addEventListener('mousedown', e => {
            if (gameState === 'playing') player.attack();
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
    </script>
</body>
</html>


